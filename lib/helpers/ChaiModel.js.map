{"version":3,"sources":["../../dist/src/helpers/ChaiModel.js"],"names":["Object","defineProperty","exports","value","_","require","immutable_1","Either_1","Equals_1","deepEqual_1","Immutable_1","isIterable","Iterable","asIterable","o","isKeyedIterable","isKeyed","asKeyedIterable","ChaiModel","chai","utils","Assertion","overwriteProperty","_super","_obj","size","assert","apply","arguments","assertCollectionEqual","expected","actual","isEqual","toJS","canEquals","deepEqual","forEach","overwriteMethod","keyword","assertCollectionInclude","v","chainCollectionInclude","overwriteChainableMethod","assertKeyedCollectionKeys","actualKeys","List","keys","expectedKeys","type","isSet","isList","isStack","TypeError","Array","prototype","slice","call","isEmpty","Error","checkAny","flag","checkContains","checkNegate","strPredicate","predicate","includes","result","some","every","Comparator","eq","fn","act","exp","name","gte","lte","gt","lt","getCollectionSize","assertCollectionSize","that","comparator","assertCollectionSizeEq","assertCollectionSizeGte","assertCollectionSizeLte","assertCollectionSizeGt","assertCollectionSizeLt","assertCollectionSizeWithin","min","max","chainCollectionSize","assertErrorEquals","errMsg","msg","expError","message","expMsg","isFunction","actMsg","isNil","RegExp","exec","isString","indexOf","assertError","length","is","a","bind","assertErrorOnLeft","Either","isLeft","to","be","true","left","get","addMethod","originalEqual","equal","originalNotEqual","notEqual","not","sizeOf","collection"],"mappings":"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","file":"ChaiModel.js","sourcesContent":["/**\n * This helper is heavily based on https://github.com/astorije/chai-immutable.\n * The main intention is to enhance the support of TypeScrpt, and integrate\n * with the support the classes in this library, such as Either, and Maybe, etc.\n *\n * Reference: https://github.com/astorije/chai-immutable\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nconst immutable_1 = require(\"immutable\");\nconst Either_1 = require(\"../core/Either\");\nconst Equals_1 = require(\"../core/Equals\");\nconst deepEqual_1 = require(\"../utils/deepEqual\");\nconst Immutable_1 = require(\"../utils/Immutable\");\nconst isIterable = immutable_1.Iterable.isIterable;\nconst asIterable = (o) => o;\nconst isKeyedIterable = immutable_1.Iterable.isKeyed;\nconst asKeyedIterable = (o) => o;\nfunction ChaiModel(chai, utils) {\n    /* tslint:disable variable-name no-unused-expression */\n    const Assertion = chai.Assertion;\n    /**\n     * ### .empty\n     *\n     * Asserts that the immutable collection is empty.\n     *\n     * ```js\n     * expect(List()).to.be.empty\n     * expect(List.of(1, 2, 3)).to.not.be.empty\n     * ```\n     *\n     * @name empty\n     * @api public\n     */\n    Assertion.overwriteProperty('empty', (_super) => {\n        return function () {\n            if (isIterable(this._obj)) {\n                const size = asIterable(this._obj).size;\n                this.assert(size === 0, 'expected immutable #{this} to be empty but got size #{act}', 'expected immutable #{this} to not be empty', 0, size);\n            }\n            else {\n                _super.apply(this, arguments);\n            }\n        };\n    });\n    /**\n     * ### .equal(collection)\n     *\n     * Asserts that the values of the target are equvalent to the values of\n     * `collection`. Aliases of Chai's original `equal` method are also supported.\n     *\n     * If both expected and actual value are immutable, then the function will\n     * convert the given values to JS object, and deep compare them.\n     *\n     * ```js\n     * var a = List.of(1, 2, 3)\n     * var b = List.of(1, 2, 3)\n     * expect(a).to.eq(b)\n     * ```\n     *\n     * @name deep.equal\n     * @alias eq\n     * @alias eql\n     * @alias eqls\n     * @alias equals\n     * @param {Collection} value\n     * @api public\n     */\n    function assertCollectionEqual(_super) {\n        return function (expected) {\n            if (isIterable(expected) && isIterable(this._obj)) {\n                const actual = asIterable(this._obj);\n                this.assert(_.isEqual(actual.toJS(), expected.toJS()), 'expected immutable #{act} to equal #{exp}', 'expected immutable #{act} to not equal #{exp}', expected, actual, true);\n            }\n            else if (Equals_1.canEquals(expected) && Equals_1.canEquals(this._obj)) {\n                const actual = this._obj;\n                this.assert(deepEqual_1.deepEqual(actual, expected), 'expected #{act} to equal #{exp}', 'expected #{act} to not equal #{exp}', expected, actual, true);\n            }\n            else {\n                _super.apply(this, arguments);\n            }\n        };\n    }\n    ['eq', 'eql', 'eqls', 'equal', 'equals'].forEach(keyword => {\n        Assertion.overwriteMethod(keyword, assertCollectionEqual);\n    });\n    /**\n     * ### .include(value)\n     *\n     * The `include` and `contain`Assertions can be used as either property\n     * based language chains or as methods to assert the inclusion of a value\n     * in an immutable collection. When used as language chains, they toggle the\n     * `contains` flag for the `keys` Assertion.\n     *\n     * ```js\n     * expect(new List([1, 2, 3])).to.include(2)\n     * expect(new List([1, 2, 3])).to.includes(2)\n     * expect(new List([1, 2, 3])).to.contain(2)\n     * expect(new List([1, 2, 3])).to.contains(2)\n     * ```\n     *\n     * @name include\n     * @alias contain\n     * @alias includes\n     * @alias contains\n     * @param {Mixed} val\n     * @api public\n     */\n    function assertCollectionInclude(_super) {\n        return function (expected) {\n            if (isIterable(this._obj)) {\n                const actual = asIterable(this._obj);\n                this.assert((v) => _.isEqual(v, expected), 'expected immutable #{act} to include #{exp}', 'expected immutable #{act} to not include #{exp}', expected, actual.toJS());\n            }\n            else {\n                _super.apply(this, arguments);\n            }\n        };\n    }\n    function chainCollectionInclude(_super) {\n        return function () { _super.apply(this, arguments); };\n    }\n    ['include', 'contain', 'contains', 'includes'].forEach(keyword => {\n        Assertion.overwriteChainableMethod(keyword, assertCollectionInclude, chainCollectionInclude);\n    });\n    /**\n     * ### .keys(key1[, key2, ...[, keyN]])\n     *\n     * Asserts that the keyed collection contains any or all of the passed-in\n     * keys. Use in combination with `any`, `all`, `contains`, or `have` will\n     * affect what will pass.\n     *\n     * When used in conjunction with `any`, at least one key that is passed in\n     * must exist in the target object. This is regardless whether or not\n     * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n     * should be used in theAssertion. If neither are used, theAssertion is\n     * defaulted to `all`.\n     *\n     * When both `all` and `contain` are used, the target object must have at\n     * least all of the passed-in keys but may have more keys not listed.\n     *\n     * When both `all` and `have` are used, the target object must both contain\n     * all of the passed-in keys AND the number of keys in the target object must\n     * match the number of keys passed in (in other words, a target object must\n     * have all and only all of the passed-in keys).\n     *\n     * `key` is an alias to `keys`.\n     *\n     * ```js\n     * expect(new Map({ foo: 1 })).to.have.key('foo')\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys('foo', 'bar')\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys(new List(['bar', 'foo']))\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Set(['bar', 'foo']))\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Stack(['bar', 'foo']))\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys(['bar', 'foo'])\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys({ 'bar': 6, 'foo': 7 })\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Map({ 'bar': 6, 'foo': 7 }))\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.any.keys('foo', 'not-foo')\n     * expect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar')\n     * expect(new Map({ foo: 1, bar: 2 })).to.contain.key('foo')\n     * ```\n     *\n     * @name keys\n     * @param {String...|Array|Object|Collection} keyN\n     * @alias key\n     * @api public\n     */\n    function assertKeyedCollectionKeys(_super) {\n        return function (expected) {\n            if (isKeyedIterable(this._obj)) {\n                const actual = asKeyedIterable(this._obj);\n                const actualKeys = immutable_1.List(actual.keys());\n                const expectedKeys = (() => {\n                    switch (utils.type(expected)) {\n                        case 'object':\n                            if (!Immutable_1.isSet(expected) && !Immutable_1.isList(expected) && !Immutable_1.isStack(expected))\n                                throw new TypeError(`Invalid expected keys, must be either List, Set, Stack, array, ` +\n                                    `or primitive datatype. But got ${expected}`);\n                            return immutable_1.List(expected);\n                        case 'array':\n                            return immutable_1.List(expected);\n                        default:\n                            return immutable_1.List(Array.prototype.slice.call(arguments));\n                    }\n                })();\n                if (expectedKeys.isEmpty())\n                    throw new Error(`expected keys required, but got ${expected}`);\n                const checkAny = utils.flag(this, 'any');\n                const checkContains = utils.flag(this, 'contains');\n                const checkNegate = utils.flag(this, 'negate');\n                const strPredicate = checkContains ? 'contain' : 'have';\n                const predicate = (value) => actualKeys.includes(value);\n                const result = (function () {\n                    if (checkAny || checkContains) {\n                        return actualKeys.some(predicate, expectedKeys)\n                            && !checkNegate;\n                    }\n                    else {\n                        return actualKeys.every(predicate, expectedKeys)\n                            && actualKeys.size === expectedKeys.size\n                            && !checkNegate;\n                    }\n                })();\n                this.assert(result, `expected immutable #{this} to ${strPredicate} keys #{exp} but got #{act}`, `expected immutable #{this} to not ${strPredicate} keys #{exp} but got #{act}`, expectedKeys, actualKeys);\n            }\n            else\n                _super.apply(this, arguments);\n        };\n    }\n    Assertion.overwriteMethod('keys', assertKeyedCollectionKeys);\n    Assertion.overwriteMethod('key', assertKeyedCollectionKeys);\n    const Comparator = {\n        eq: {\n            fn: (act, exp) => act == exp,\n            name: 'equals',\n        },\n        gte: {\n            fn: (act, exp) => act >= exp,\n            name: 'greater than or equals to',\n        },\n        lte: {\n            fn: (act, exp) => act <= exp,\n            name: 'less than or equals to',\n        },\n        gt: {\n            fn: (act, exp) => act > exp,\n            name: 'greater than',\n        },\n        lt: {\n            fn: (act, exp) => act < exp,\n            name: 'less than',\n        },\n    };\n    function getCollectionSize(o) {\n        return isIterable(o) ? asIterable(o).size : _.size(o);\n    }\n    function assertCollectionSize(that, expected, comparator) {\n        const actual = getCollectionSize(that._obj);\n        that.assert(comparator.fn(actual, expected), `expected immutable #{this} to have size ${comparator.name} #{exp} but got #{act}`, `expected immutable #{this} to not have size ${comparator.name} #{exp}`, expected, actual, true);\n    }\n    function assertCollectionSizeEq(_super) {\n        return function (expected) {\n            assertCollectionSize(this, expected, Comparator.eq);\n        };\n    }\n    function assertCollectionSizeGte(_super) {\n        return function (expected) {\n            assertCollectionSize(this, expected, Comparator.gte);\n        };\n    }\n    function assertCollectionSizeLte(_super) {\n        return function (expected) {\n            assertCollectionSize(this, expected, Comparator.lte);\n        };\n    }\n    function assertCollectionSizeGt(_super) {\n        return function (expected) {\n            assertCollectionSize(this, expected, Comparator.gt);\n        };\n    }\n    function assertCollectionSizeLt(_super) {\n        return function (expected) {\n            assertCollectionSize(this, expected, Comparator.lt);\n        };\n    }\n    function assertCollectionSizeWithin(_super) {\n        return function (min, max) {\n            const size = getCollectionSize(this._obj);\n            this.assert(min <= size && size <= max, 'expected immutable #{this} to have a size within #{exp} but got #{act}', 'expected immutable #{this} to not have a size within #{exp} but got #{act}', min + '..' + max, size);\n        };\n    }\n    function chainCollectionSize() {\n        utils.flag(this, 'immutable.collection.size', true);\n    }\n    Assertion.overwriteMethod('sizeOf', assertCollectionSizeEq);\n    Assertion.overwriteMethod('lengthOf', assertCollectionSizeEq);\n    Assertion.overwriteMethod('gte', assertCollectionSizeGte);\n    Assertion.overwriteMethod('least', assertCollectionSizeGte);\n    Assertion.overwriteMethod('lte', assertCollectionSizeLte);\n    Assertion.overwriteMethod('most', assertCollectionSizeLte);\n    Assertion.overwriteMethod('gt', assertCollectionSizeGt);\n    Assertion.overwriteMethod('above', assertCollectionSizeGt);\n    Assertion.overwriteMethod('greaterThan', assertCollectionSizeGt);\n    Assertion.overwriteMethod('lt', assertCollectionSizeLt);\n    Assertion.overwriteMethod('below', assertCollectionSizeLt);\n    Assertion.overwriteMethod('lessThan', assertCollectionSizeLt);\n    Assertion.overwriteMethod('within', assertCollectionSizeWithin);\n    /**\n     * ### .error(constructor)\n     *\n     * Asserts that the values of the target is equals to a specific error, or specific type\n     * of error (as determined using `instanceof`), optionally with a RegExp or string inclusion\n     * test for the error's message.\n     *\n     *     var err = new ReferenceError('This is a bad function.')\n     *     expect(err).to.be.error(ReferenceError)\n     *     expect(err).to.be.error(Error)\n     *     expect(err).to.be.error(/bad function/)\n     *     expect(err).to.not.be.error('good function')\n     *     expect(err).to.be.error(ReferenceError, /bad function/)\n     *     expect(err).to.be.error(err)\n     *\n     * @name error\n     * @param {ErrorConstructor} constructor\n     * @param {String|RegExp} expected error message\n     * @param {String} message _optional_\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @returns error for chaining (null if no error)\n     * @namespace BDD\n     * @api public\n     */\n    function assertErrorEquals(expected, actual, errMsg, msg) {\n        // CASE: Expected to be a desired error\n        if (expected && expected instanceof Error) {\n            const expError = expected;\n            this.assert(_.eq(expError.name, actual.name) &&\n                _.eq(expError.message, actual.message), 'expected error to equal #{exp} but got #{act}', 'expected error to not equal #{exp} but got #{act}', expError, actual);\n            return this;\n        }\n        // CASE: Expected to be of a desired error type\n        if (typeof expected === 'function') {\n            let name = expected.prototype.name;\n            if (!name || (name == 'Error' && expected !== Error)) {\n                name = expected.name || (new expected()).name;\n            }\n            this.assert(_.eq(name, actual.name), 'expected #{this} with type #{exp} but got #{act}', 'expected #{this} not with type #{exp} but got #{act}', name, actual.name);\n            if (!errMsg)\n                return this;\n        }\n        const expMsg = _.isFunction(expected) ? errMsg : expected;\n        const actMsg = 'message' in actual ? actual.message : '' + actual;\n        // CASE: Expected to have error message matches regex\n        if (!_.isNil(actMsg) && !!expMsg && expMsg instanceof RegExp) {\n            this.assert(expMsg.exec(actMsg), 'expected #{this} to have error message matching #{exp} but got #{act}', 'expected #{this} to have error message not matching #{exp}', expMsg, actMsg);\n            return this;\n        }\n        else if (!_.isNil(actMsg) && !!expMsg && _.isString(expMsg)) {\n            this.assert(~expMsg.indexOf(actMsg), 'expected #{this} to have error message including #{exp} but got #{act}', 'expected #{this} to have error message not including #{act}', expMsg, actMsg);\n            return this;\n        }\n        else {\n            throw new Error('Must specify expected message or regex.' + errMsg);\n        }\n    }\n    function assertError(expected, errMsg, msg) {\n        if (arguments.length === 0) {\n            throw new Error('Must have expected error.');\n        }\n        if (!!msg)\n            utils.flag(this, 'message', msg);\n        const actual = utils.flag(this, 'object');\n        new Assertion(actual, msg).is.a('error');\n        return assertErrorEquals.bind(this)(expected, actual, errMsg, msg);\n    }\n    function assertErrorOnLeft(expected, errMsg, msg) {\n        if (arguments.length === 0) {\n            throw new Error('Must have expected error.');\n        }\n        if (!!msg)\n            utils.flag(this, 'message', msg);\n        const actual = utils.flag(this, 'object');\n        new Assertion(Either_1.Either.isLeft(actual), `expected an Either.Left instance, but got ${this}`).to.be.true;\n        return assertErrorEquals.bind(this)(expected, actual.left.get, errMsg, msg);\n    }\n    Assertion.addMethod('error', assertError);\n    Assertion.addMethod('errorOnLeft', assertErrorOnLeft);\n    /**\n     * ## TDD API Reference\n     */\n    const assert = chai.assert;\n    const originalEqual = assert.equal;\n    const originalNotEqual = assert.notEqual;\n    /**\n     * ### .equal(actual, expected)\n     *\n     * Asserts that the values of `actual` are equivalent to the values of\n     * `expected`. Note that `.strictEqual()` and `.deepEqual()` assert\n     * exactly like `.equal()` in the context of Immutable data structures.\n     *\n     * ```js\n     * var a = List.of(1, 2, 3)\n     * var b = List.of(1, 2, 3)\n     * assert.equal(a, b)\n     * ```\n     *\n     * Immutable data structures should only contain other immutable data\n     * structures (unlike `Array`s and `Object`s) to be considered immutable and\n     * properly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n     * [this issue](https://github.com/astorije/chai-immutable/issues/24) for\n     * more information.\n     *\n     * @name equal\n     * @param {Collection} actual\n     * @param {Collection} expected\n     * @api public\n     */\n    assert.equal = (actual, expected) => {\n        if (isIterable(actual)) {\n            return new Assertion(actual).equal(expected);\n        }\n        else\n            return originalEqual(actual, expected);\n    };\n    /**\n     * ### .notEqual(actual, expected)\n     *\n     * Asserts that the values of `actual` are not equivalent to the values of\n     * `expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\n     * exactly like `.notEqual()` in the context of Immutable data structures.\n     *\n     * ```js\n     * var a = List.of(1, 2, 3)\n     * var b = List.of(4, 5, 6)\n     * assert.notEqual(a, b)\n     * ```\n     *\n     * @name notEqual\n     * @param {Collection} actual\n     * @param {Collection} expected\n     * @api public\n     */\n    assert.notEqual = (actual, expected) => {\n        if (isIterable(actual)) {\n            return new Assertion(actual).not.equal(expected);\n        }\n        else\n            return originalNotEqual(actual, expected);\n    };\n    /**\n     * ### .sizeOf(collection, length)\n     *\n     * Asserts that the immutable collection has the expected size.\n     *\n     * ```js\n     * assert.sizeOf(List.of(1, 2, 3), 3)\n     * assert.sizeOf(new List(), 0)\n     * ```\n     *\n     * @name sizeOf\n     * @param {Collection} collection\n     * @param {Number} size\n     * @api public\n     */\n    assert.sizeOf = (collection, expected) => {\n        new Assertion(collection).size(expected);\n    };\n}\nexports.ChaiModel = ChaiModel;\n//# sourceMappingURL=ChaiModel.js.map"]}