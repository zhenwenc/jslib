{"version":3,"sources":["../../dist/src/core/Either.js"],"names":["Object","defineProperty","exports","value","Maybe_1","require","Record_1","deepEqual_1","Either","a","b","fa","fb","isLeft","getIsLeft","getIsRight","LeftProjection","RightProjection","Right","Left","LeftWrapper","RightWrapper","isEither","isRight","Record","undefined","that","deepEqual","left","get","right","e","or","fn","Error","Just","Nothing"],"mappings":"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","file":"Either.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable:no-unused-variable */\nconst Maybe_1 = require(\"./Maybe\");\nconst Record_1 = require(\"./Record\");\nconst deepEqual_1 = require(\"../utils/deepEqual\");\n/* tslint:enable:no-unused-variable */\n// -- Either Class ------------------------------------------------------------\nclass Either extends Record_1.Record {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    static Left(value) {\n        return new LeftWrapper(value);\n    }\n    static Right(value) {\n        return new RightWrapper(value);\n    }\n    static isEither(value) {\n        return value instanceof Either;\n    }\n    static isLeft(value) {\n        return Either.isEither(value) && value.isLeft;\n    }\n    static isRight(value) {\n        return Either.isEither(value) && value.isRight;\n    }\n    get isLeft() {\n        return this.getIsLeft();\n    }\n    get isRight() {\n        return this.getIsRight();\n    }\n    get left() {\n        return new LeftProjection(this);\n    }\n    get right() {\n        return new RightProjection(this);\n    }\n    get swap() {\n        return this.isLeft\n            ? Either.Right(this.a)\n            : Either.Left(this.b);\n    }\n    /**\n     * Applies `fa` if this is a `Left` or `fb` if this is a `Right`.\n     *\n     * @param  {Function} fa the function to apply if this is a `Left`\n     * @param  {Function} fb the function to apply if this is a `Right`\n     * @return {Any}         the results of applying the function\n     */\n    fold(fa, fb) {\n        return this.isLeft ? fa(this.a) : fb(this.b);\n    }\n}\nexports.Either = Either;\n// -- Left / Right Class ------------------------------------------------------\nclass LeftWrapper extends Either {\n    constructor(value) { super(value, undefined); }\n    getIsLeft() { return true; }\n    getIsRight() { return false; }\n    equals(that) {\n        return Either.isLeft(that)\n            && deepEqual_1.deepEqual(this.left.get, that.left.get);\n    }\n    toString() {\n        return `Left(${this.a})`;\n    }\n}\nclass RightWrapper extends Either {\n    constructor(value) { super(undefined, value); }\n    getIsLeft() { return false; }\n    getIsRight() { return true; }\n    equals(that) {\n        return Either.isRight(that)\n            && deepEqual_1.deepEqual(this.right.get, that.right.get);\n    }\n    toString() {\n        return `Right(${this.b})`;\n    }\n}\n// -- Left / Right Projection Class -------------------------------------------\nclass LeftProjection extends Record_1.Record {\n    constructor(e) {\n        super();\n        this.e = e;\n    }\n    /**\n     * Returns the value from this `Either` if this is of a `Left`, otherwise\n     * throws an Error.\n     *\n     * @return {Any}\n     */\n    get get() {\n        if (this.e.isLeft) {\n            return this.e.a;\n        }\n        throw new Error(`Want Either.left.value, but on Right`);\n    }\n    /**\n     * Returns a `Just` containing the `Either` value if this is of a `Left`\n     * or a `Nothing` if this is of a `Right`.\n     *\n     * {{{\n     * \tLeft(12).left.toMaybe // Just(12)\n     * \tRight(12).left.toMaybe // Nothing\n     * }}}\n     *\n     * @return {Maybe}\n     */\n    get toMaybe() {\n        return this.e.isLeft ? Maybe_1.Just(this.get) : Maybe_1.Nothing;\n    }\n    /**\n     * Returns the value from this `Either` if this is of a `Left`, or the given\n     * argument if this is of a `Right`.\n     *\n     * @param  {Any} or The default value\n     * @return {Any}\n     */\n    getOrElse(or) {\n        return this.e.isLeft ? this.get : or;\n    }\n    /**\n     * Maps the function argument through `Left` if this is of a `Left`,\n     * otherwise returns the original `Eihter`.\n     *\n     * @param  {Function} fn The function to map\n     * @return {Either}\n     */\n    map(fn) {\n        return this.e.isLeft\n            ? Either.Left(fn(this.get))\n            : Either.Right(this.e.right.get);\n    }\n    /**\n     * Binds the given function across `Left` if this is of a `Left`, otherwise\n     * returns the original `Either`. Slightly different from `map` is that `fn`\n     * is expected to return an `Either`.\n     *\n     * @param  {Function} fn The function to bind accross the `Left`\n     * @return {Either}\n     */\n    flatMap(fn) {\n        return this.e.isLeft ? fn(this.get) : Either.Right(this.e.right.get);\n    }\n    equals(that) {\n        return that instanceof LeftProjection\n            && deepEqual_1.deepEqual(this.get, that.get);\n    }\n    toString() { return `LeftProjection(${this.e})`; }\n}\nexports.LeftProjection = LeftProjection;\nclass RightProjection extends Record_1.Record {\n    constructor(e) {\n        super();\n        this.e = e;\n    }\n    /**\n     * Returns the value from this `Either` if this is of a `Right`, otherwise\n     * throws an Error.\n     *\n     * @return {Any}\n     */\n    get get() {\n        if (this.e.isRight) {\n            return this.e.b;\n        }\n        throw new Error(`Want Either.right.value, but on Left`);\n    }\n    /**\n     * Returns a `Just` containing the `Either` value if this is of a `Right`\n     * or a `Nothing` if this is a `Left`.\n     *\n     * {{{\n     * \tRight(21).right.toMaybe // Just(21)\n     * \tLeft(21).right.toMaybe // Nothing\n     * }}}\n     *\n     * @return {Maybe}\n     */\n    get toMaybe() {\n        return this.e.isRight ? Maybe_1.Just(this.get) : Maybe_1.Nothing;\n    }\n    /**\n     * Returns the value from this `Either` if this is of a `Right`, or the given\n     * argument if this is of a `Left`.\n     *\n     * @param  {Any} or The default value\n     * @return {Any}\n     */\n    getOrElse(or) {\n        return this.e.isRight ? this.get : or;\n    }\n    /**\n     * Maps the function argument through `Right` if this is of a `Right`,\n     * otherwise returns the original `Eihter`.\n     *\n     * @param  {Function} fn The function to map\n     * @return {Either}\n     */\n    map(fn) {\n        return this.e.isRight\n            ? Either.Right(fn(this.get))\n            : Either.Left(this.e.left.get);\n    }\n    /**\n     * Binds the given function across `Right` if this is of a `Right`, otherwise\n     * returns the original `Either`. Slightly different from `map` is that `fn`\n     * is expected to return an `Either`.\n     *\n     * @param  {Function} fn The function to bind accross the `Right`\n     * @return {Either}\n     */\n    flatMap(fn) {\n        return this.e.isRight ? fn(this.get) : Either.Left(this.e.left.get);\n    }\n    equals(that) {\n        return that instanceof RightProjection\n            && deepEqual_1.deepEqual(this.get, that.get);\n    }\n    toString() { return `RightProjection(${this.e})`; }\n}\nexports.RightProjection = RightProjection;\n// -- Aliases -----------------------------------------------------------------\n/* tslint:disable variable-name */\nexports.Left = Either.Left;\nexports.Right = Either.Right;\n//# sourceMappingURL=Either.js.map"]}