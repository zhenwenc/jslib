{"version":3,"sources":["../../dist/src/core/Maybe.js"],"names":["Object","defineProperty","exports","value","Either_1","require","Record_1","deepEqual_1","Maybe","or","isNothing","get","err","isJust","alt","apply","undefined","fn","Just","NothingWrapper","ifEmpty","f","left","Right","Left","right","isEmpty","isDefined","Error","Nothing","of","JustWrapper","gen","next","result","done","flatMap","a","b","c","Record","that","deepEqual"],"mappings":"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","file":"Maybe.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Either_1 = require(\"./Either\");\nconst Record_1 = require(\"./Record\");\nconst deepEqual_1 = require(\"../utils/deepEqual\");\n// -- Maybe Class -------------------------------------------------------------\nclass Maybe extends Record_1.Record {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /**\n     * Constructs a new `Maybe` instance.\n     *\n     * If the value is either `null` or `undefined`, the function returns a\n     * `Nothing`, otherwise the value is wrapped in a `Just(val)`\n     *\n     * @param  {Any}          value the value to wrap\n     * @return {Just|Nothing}       Returns `Nothing` if `value` is null or\n     *                              undefined, else `Just`\n     */\n    static of(value) {\n        return (value === null || value === undefined)\n            ? exports.Nothing : Just(value);\n    }\n    /**\n     * Constructs a new `Maybe` instance with the evaluated value of the given\n     * function.\n     *\n     * @param  {Function} fn the function to be evaluated\n     * @return {Maybe}\n     */\n    static eval(fn) {\n        return Maybe.of(fn.apply(undefined));\n    }\n    /**\n     * Check if `value` is subtype of `Maybe`, either `Just` or `Nothing`.\n     *\n     * @param  {Any}     value the value to check.\n     * @return {Boolean}       Returns `true` if `value` is subtype of `Maybe`\n     */\n    static isMaybe(value) {\n        return value instanceof Maybe;\n    }\n    /**\n     * Check if `value` is `Just`.\n     *\n     * @param  {Any}     value The value to check.\n     * @return {Boolean}\n     */\n    static isJust(value) {\n        return value instanceof JustWrapper;\n    }\n    /**\n     * Check if `value` is `Just`.\n     *\n     * Alias to Maybe#isJust\n     */\n    static isDefined(value) {\n        return Maybe.isJust(value);\n    }\n    /**\n     * Check if `value` is `Nothing`.\n     *\n     * @param  {Any}     value The value to check.\n     * @return {Boolean}\n     */\n    static isNothing(value) {\n        return value instanceof NothingWrapper;\n    }\n    /**\n     * Check if `value` is `Just`, and the contained value is defined.\n     *\n     * @param  {Maybe}   value The value to check.\n     * @return {Boolean}\n     */\n    static isEmpty(value) {\n        return Maybe.isNothing(value)\n            || value.get === null\n            || value.get === undefined;\n    }\n    /**\n     * Do notation for working with ES6 generator.\n     *\n     * Note: the given generator must yield a Maybe at every iteration.\n     *\n     * @param  {Generator} gen a generator\n     * @return {Maybe}\n     */\n    static run(gen) {\n        function next(value) {\n            const result = gen.next(value);\n            if (result.done) {\n                return result.value || Maybe.of(value);\n            }\n            return result.value.flatMap(next);\n        }\n        return next(null);\n    }\n    /**\n     * Apply given function to values wrapped in `Maybe`, and wrap the result in another\n     * `Maybe`. If any of the argument is a `Nothing`, return `Nothing`.\n     *\n     * @param {Function} function to apply\n     * @param {Maybe} a\n     * @param {Maybe} b\n     * @return {Maybe}\n     */\n    static lift2(f, a, b) {\n        if (a.isJust && b.isJust) {\n            return Just(f(a.get, b.get));\n        }\n        else {\n            return exports.Nothing;\n        }\n    }\n    /**\n     * Apply given function to values wrapped in `Maybe`, and wrap the result in another\n     * `Maybe`. If any of the argument is a `Nothing`, return `Nothing`.\n     *\n     * @param {Function} function to apply\n     * @param {Maybe} a\n     * @param {Maybe} b\n     * @param {Maybe} c\n     * @return {Maybe}\n     */\n    static lift3(f, a, b, c) {\n        if (a.isJust && b.isJust && c.isJust) {\n            return Just(f(a.get, b.get, c.get));\n        }\n        else {\n            return exports.Nothing;\n        }\n    }\n    /**\n     * Return `true` if this is a `Just` instance.\n     *\n     * @return {Boolean} Returns `true` if this is a `Just` instance\n     */\n    get isJust() {\n        return Maybe.isJust(this);\n    }\n    /**\n     * Return `true` if this is a `Nothing` instance.\n     *\n     * @return {Boolean} Returns `true` if this is a `Nothing` instance\n     */\n    get isNothing() {\n        return Maybe.isNothing(this);\n    }\n    /**\n     * Return `true` if this is not a `Just` instance, or the contained\n     * value is null or undefined. Otherwise, return `false`.\n     *\n     * @return {Boolean}\n     */\n    get isEmpty() {\n        return Maybe.isEmpty(this);\n    }\n    /**\n     * Return `true` if this is a `Just` instance. Otherwise, return `false`.\n     *\n     * @return {Boolean}\n     */\n    get isDefined() {\n        return Maybe.isDefined(this);\n    }\n    /**\n     * Returns the maybe's value.\n     *\n     * @return {Any}\n     */\n    get get() {\n        if (this.isNothing) {\n            throw Error(`Can't get value from Nothing.`);\n        }\n        return this.value;\n    }\n    toString() {\n        return `Maybe(${this.value})`;\n    }\n    // -- Functions -------------------------------------------------------------\n    /**\n     * Returns the maybe's value if the maybe is a `Just`, otherwise return the\n     * default value `or`.\n     *\n     * @param  {Any} or the default expression\n     * @return {Any}\n     */\n    getOrElse(or) {\n        return this.isNothing ? or : this.get;\n    }\n    /**\n     * Returns the maybe's value if the maybe is a `Just`, otherwise throw the\n     * given `err` which can be either custom error or any object.\n     *\n     * @param  {Error} err Rubbish to throw :)\n     * @return {Any}\n     */\n    getOrThrow(err) {\n        if (this.isJust) {\n            return this.get;\n        }\n        throw err;\n    }\n    /**\n     * Returns this `Maybe` if it is a `Just`, otherwise return the result of\n     * evaluating `alt`.\n     *\n     * @param  {Function} alt the alternative expression\n     * @return {Maybe}\n     */\n    orElse(alt) {\n        return this.isNothing ? alt.apply(undefined) : this;\n    }\n    /**\n     * Returns a `Just` containing the result of applying `fn` to this `Maybe` value\n     * if this `Maybe` is a `Just`. Otherwise return `Nothing`.\n     *\n     * @param  {Function} fn the function to apply\n     * @return {Maybe}\n     */\n    map(fn) {\n        return this.isJust ? Just(fn(this.get)) : new NothingWrapper;\n    }\n    /**\n     * Returns the result of applying `fn` to the value of this `Maybe` if this is\n     * a `Just`. Returns `Nothing` if this is a `Nothing`.\n     *\n     * Slightly different from `map` is that `fn` is expected to return a `Maybe`\n     * (which could be `Nothing`).\n     *\n     * @param  {Function} fn the function to apply\n     * @return {Maybe}\n     */\n    flatMap(fn) {\n        return this.isJust ? fn(this.get) : new NothingWrapper;\n    }\n    /**\n     * Return the result of applying `f` to the value of this `Maybe` if this is\n     * a `Just`. Otherwise, evaluates expression `ifEmpty`.\n     *\n     * @param  {Function} ifEmpty the expression to evaluete if this is a `Nothing`\n     * @param  {Function} f       the function to apply if this is a `Just`\n     * @return {Any}\n     */\n    fold(ifEmpty, f) {\n        return this.isJust ? f(this.get) : ifEmpty();\n    }\n    /**\n     * Transforms the value of this `Maybe` using an unary function to monads.\n     *\n     * - if this is a `Just`, then return a function that applying the given\n     * \t function with the value of this `Maybe`\n     *\n     * - if this is a `Nothing`, then return an identity function of this Maybe\n     *\n     * @return {Function}\n     */\n    chain(fn) {\n        return this.isJust ? (() => fn(this.get)) : (() => new NothingWrapper);\n    }\n    /**\n     * Return a `Right` containing this maybe's value if this is a `Just`, or\n     * a `Left` containing the given `left` if this is a `Nothing`.\n     *\n     * @param  {Any}     left the value to return if this is a Nothing\n     * @param  {Boolean} ev   evaluate if `left` is a function\n     * @return {Maybe}\n     */\n    toRight(left) {\n        return this.isJust ? Either_1.Right(this.get) : Either_1.Left(left);\n    }\n    /**\n     * Return a `Left` containing this maybe's value if this is a `Nothing`,\n     * or a `Right` containing the given `right` if this is a `Just`.\n     *\n     * @param  {Any}     right the value to return if this is a `Nothing`\n     * @param  {Boolean} ev    evaluate if `right` is a function\n     * @return {Maybe}\n     */\n    toLeft(right) {\n        return this.isJust ? Either_1.Left(this.get) : Either_1.Right(right);\n    }\n}\nexports.Maybe = Maybe;\n// -- Just Class --------------------------------------------------------------\nclass JustWrapper extends Maybe {\n    constructor(value) {\n        super(value);\n    }\n    toString() {\n        return `Just(${this.value})`;\n    }\n    equals(that) {\n        return Maybe.isJust(that)\n            && deepEqual_1.deepEqual(that.value, this.value);\n    }\n}\nexports.JustWrapper = JustWrapper;\n// -- Nothing Class ----------------------------------------------------------\nclass NothingWrapper extends Maybe {\n    constructor() {\n        super(undefined);\n    }\n    toString() {\n        return 'Nothing';\n    }\n    equals(that) {\n        return Maybe.isNothing(that);\n    }\n}\nexports.NothingWrapper = NothingWrapper;\n// -- Aliases -----------------------------------------------------------------\n/**\n * Returns a `Just` instance with the given value.\n *\n * @param  {Any}  value The value to wrap.\n * @return {Just}       Returns a `Just`\n */\nfunction Just(value) {\n    return new JustWrapper(value);\n}\nexports.Just = Just;\n/**\n * Returns the singleton `Nothing` instance.\n *\n * @return {Nothing} Returns the singleton `Nothing`.\n */\nexports.Nothing = new NothingWrapper;\n//# sourceMappingURL=Maybe.js.map"]}